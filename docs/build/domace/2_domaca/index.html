<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>2. domača naloga · Numerična matematika na FRI</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Numerična matematika na FRI</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Domov</a></li><li><span class="tocitem">Uvod</span><ul><li><a class="tocitem" href="../../vaje/1_uvod/01_koren/">Računanje kvadratnega korena</a></li><li><a class="tocitem" href="../../vaje/1_uvod/02_pi/">Računanje števila <span>$\pi$</span></a></li></ul></li><li><span class="tocitem">Linearni sistemi</span><ul><li><a class="tocitem" href="../../vaje/2_linearni_sistemi/02_tridiagonalni_sistemi/">Tridiagonalni sistemi</a></li><li><a class="tocitem" href="../../vaje/2_linearni_sistemi/03_minimalne_ploskve/">Minimalne ploskve (Laplaceova enačba)</a></li><li><a class="tocitem" href="../../vaje/2_linearni_sistemi/04_iteracijske_metode/">Iteracijske metode</a></li><li><a class="tocitem" href="../../vaje/2_linearni_sistemi/05_implicitne_ploskve/">Interpolacija z implicitnimi funkcijami</a></li></ul></li><li><span class="tocitem">Lastne vrednosti</span><ul><li><a class="tocitem" href="../../vaje/3_lastne_vrednosti/06_konj/">Konj na šahovnici</a></li><li><a class="tocitem" href="../../vaje/3_lastne_vrednosti/06_spektralno_grucenje/">Spektralno razvrščanje v gruče</a></li></ul></li><li><span class="tocitem">Nelinearne enačbe</span><ul><li><a class="tocitem" href="../../vaje/4_nelinearne_enacbe/01_konvergenca/">Konvergenčna območja iteracijskih metod</a></li><li><a class="tocitem" href="../../vaje/4_nelinearne_enacbe/02_razdalja/">Nelinearne enačbe in geometrija</a></li></ul></li><li><span class="tocitem">Interpolacija, aproksimacija</span><ul><li><a class="tocitem" href="../../vaje/5_interpolacija/07_zlepki/">Interpolacija z zlepki</a></li><li><a class="tocitem" href="../../vaje/6_aproksimacija/co2/">Aproksimacija z linearnim modelom</a></li><li><a class="tocitem" href="../../vaje/6_aproksimacija/08_chebfun/">Aproksimacija s polinomi Čebiševa</a></li></ul></li><li><span class="tocitem">Integral</span><ul><li><a class="tocitem" href="../../vaje/7_integral/10_quad/">Integrali</a></li><li><a class="tocitem" href="../../vaje/7_integral/11_quadnD/">Večrazsežni integrali</a></li></ul></li><li><span class="tocitem">Odvod</span><ul><li><a class="tocitem" href="../../vaje/8_odvod/12_autodiff/">Automatsko odvajanje</a></li></ul></li><li><span class="tocitem">Diferencialne enačbe</span><ul><li><a class="tocitem" href="../../vaje/9_nde/13_lotka_volterra/">Populacijska dinamika</a></li><li><a class="tocitem" href="../../vaje/9_nde/14_perioda/">Perioda geostacionarne orbite</a></li></ul></li><li><span class="tocitem">Domače naloge</span><ul><li><a class="tocitem" href="../1_domaca/">1. domača naloga</a></li><li class="is-active"><a class="tocitem" href>2. domača naloga</a><ul class="internal"><li><a class="tocitem" href="#Navodila"><span>Navodila</span></a></li></ul></li><li><a class="tocitem" href="../3_domaca/">3. domača naloga</a></li><li><a class="tocitem" href="../4_domaca/">4. domača naloga</a></li><li><a class="tocitem" href="../../contributing/">Kako sodelovati pri predmetu Numerična matematika</a></li><li><a class="tocitem" href="../../workflow/">Developer documentation</a></li></ul></li><li><span class="tocitem">Knjižnica</span><ul><li><a class="tocitem" href="../../lib/public/">Vidne funkcije</a></li><li><a class="tocitem" href="../../lib/internals/">Skrite funkcije</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Domače naloge</a></li><li class="is-active"><a href>2. domača naloga</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>2. domača naloga</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://gitlab.com/nummat/vaje-nummat/blob/master/docs/src/domace/2_domaca.md#" title="Edit on GitLab"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitLab</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id=".-domača-naloga"><a class="docs-heading-anchor" href="#.-domača-naloga">2. domača naloga</a><a id=".-domača-naloga-1"></a><a class="docs-heading-anchor-permalink" href="#.-domača-naloga" title="Permalink"></a></h1><ul><li><a href="#.-domača-naloga">2. domača naloga</a></li><ul><li><a href="#Navodila">Navodila</a></li><ul><li><a href="#SOR-iteracija-za-razpršene-matrike">SOR iteracija za razpršene matrike</a></li><li><a href="#Metoda-konjugiranih-gradientov-za-razpršene-matrike">Metoda konjugiranih gradientov za razpršene matrike</a></li><li><a href="#Metoda-konjugiranih-gradientov-s-predpogojevanjem">Metoda konjugiranih gradientov s predpogojevanjem</a></li><li><a href="#QR-razcep-zgornje-hessenbergove-matrike">QR razcep zgornje hessenbergove matrike</a></li><li><a href="#QR-razcep-simetrične-tridiagonalne-matrike">QR razcep simetrične tridiagonalne matrike</a></li><li><a href="#Inverzna-potenčna-metoda-za-zgornje-hessenbergovo-matriko">Inverzna potenčna metoda za zgornje hessenbergovo matriko</a></li><li><a href="#Inverzna-potenčna-metoda-za-tridiagonalno-matriko">Inverzna potenčna metoda za tridiagonalno matriko</a></li><li><a href="#Naravni-zlepek">Naravni zlepek</a></li><li><a href="#QR-iteracija-z-enojnim-premikom">QR iteracija z enojnim premikom</a></li></ul></ul></ul><h2 id="Navodila"><a class="docs-heading-anchor" href="#Navodila">Navodila</a><a id="Navodila-1"></a><a class="docs-heading-anchor-permalink" href="#Navodila" title="Permalink"></a></h2><p>Izberite eno izmed spodnjih nalog. Po možnosti tako, ki je ni še nihče drug izbral (preverite <a href="https://gitlab.com/nummat/nummat-1920/issues">zahtevke na Gitlabu</a>).</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Domačo nalogo lahko delate skupaj s kolegi, vendar morate v tem primeru rešiti toliko različnih nalog, kot je študentov v skupini.</p></div></div><h3 id="SOR-iteracija-za-razpršene-matrike"><a class="docs-heading-anchor" href="#SOR-iteracija-za-razpršene-matrike">SOR iteracija za razpršene matrike</a><a id="SOR-iteracija-za-razpršene-matrike-1"></a><a class="docs-heading-anchor-permalink" href="#SOR-iteracija-za-razpršene-matrike" title="Permalink"></a></h3><p>Naj bo <em>A n × n</em> diagonalno dominantna razpršena matrika(velika večina elementov je ničelnih <span>$a_{ij}=0$</span>).</p><p>Definirajte nov podatkovni tip <code>RazprsenaMatrika</code>, ki matriko zaradi prostorskih zahtev hrani v dveh matrikah <span>$V$</span> in <span>$I$</span>, kjer sta <span>$V$</span> in <span>$I$</span> matriki <span>$n \times m$</span>, tako da velja</p><p class="math-container">\[V(i,j)=A(i,I(i,j)).\]</p><p>V matriki <span>$V$</span> se torej nahajajo neničelni elementi matrike <span>$A$</span>. Vsaka vrstica matrike <span>$V$</span> vsebuje ničelne elemente iz iste vrstice v <span>$A$</span>. V matriki <span>$I$</span> pa so shranjeni indeksi stolpcev teh neničelnih elementov.</p><p>Za podatkovni tip <code>RazprsenaMatrika</code> definirajte metode za naslednje funkcije:</p><ul><li>indeksiranje: <code>Base.getindex</code>,<code>Base.setindex!</code>,<code>Base.firstindex</code> in <code>Base.lastindex</code></li><li>množenje z desne <code>Base.*</code> z vektorjem</li></ul><p>Več informacij o <a href="https://docs.julialang.org/en/v1/manual/types/">tipih</a> in <a href="https://docs.julialang.org/en/v1/manual/interfaces/">vmesnikih</a>.</p><p>Napišite funkcijo <code>x, it = sor(A, b, x0, omega, tol=1e-10)</code>, ki reši tridiagonalni sistem <span>$Ax=b$</span> z SOR iteracijo. Pri tem je <code>x0</code> začetni približek, <code>tol</code> pogoj za ustavitev iteracije in <code>omega</code> parameter pri SOR iteraciji. Iteracija naj se ustavi, ko je</p><p class="math-container">\[|A\mathbf{x}^{(k)}-\mathbf{b}|_\infty &lt; nat.\]</p><p>Metodo uporabite za vožitev grafa v ravnino ali prostor <a href="https://en.wikipedia.org/wiki/Force-directed_graph_drawing">s fizikalno metodo</a>. Če so <span>$(x_i, y_i, z_i)$</span> koordinate vozlišč grafa v prostoru, potem vsaka koordinata posebej zadošča enačbam</p><p class="math-container">\[\begin{array}{lcl}
 -st(i)x_i + \sum_{j\in N(i)} x_j &amp;=&amp; 0,\\
 -st(i)y_i + \sum_{j\in N(i)} y_j &amp;=&amp; 0,\\
 -st(i)z_i + \sum_{j\in N(i)} z_j &amp;=&amp; 0,
 \end{array}\]</p><p>kjer je <span>$st(i)$</span> stopnja <span>$i$</span>-tega vozlišča, <span>$N(i)$</span> pa množica indeksov sosednjih vozlišč. Če nekatera vozlišča fiksiramo, bodo ostala zavzela ravnovesno lego med fiksiranimi vozlišči.</p><p>Za primere, ki jih boste opisali, poiščite optimalni <code>omega</code>, pri katerem SOR najhitreje konvergira in predstavite odvisnost hitrosti konvergence od izbire <span>$\omega$</span>.</p><h3 id="Metoda-konjugiranih-gradientov-za-razpršene-matrike"><a class="docs-heading-anchor" href="#Metoda-konjugiranih-gradientov-za-razpršene-matrike">Metoda konjugiranih gradientov za razpršene matrike</a><a id="Metoda-konjugiranih-gradientov-za-razpršene-matrike-1"></a><a class="docs-heading-anchor-permalink" href="#Metoda-konjugiranih-gradientov-za-razpršene-matrike" title="Permalink"></a></h3><p>Definirajte nov podatkovni tip <code>RazprsenaMatrika</code>, kot je opisano v prejšnji nalogi.</p><p>Napišite funkcijo <code>[x,i]=conj_grad(A, b)</code>, ki reši sistem</p><p class="math-container">\[Ax=b,\]</p><p>z metodo konjugiranih gradientov za <code>A</code> tipa <code>RazprsenaMatrika</code>.</p><p>Metodo uporabite na primeru vložitve grafa v ravnino ali prostor s fizikalno metodo, kot je opisano v prejšnji nalogi.</p><h3 id="Metoda-konjugiranih-gradientov-s-predpogojevanjem"><a class="docs-heading-anchor" href="#Metoda-konjugiranih-gradientov-s-predpogojevanjem">Metoda konjugiranih gradientov s predpogojevanjem</a><a id="Metoda-konjugiranih-gradientov-s-predpogojevanjem-1"></a><a class="docs-heading-anchor-permalink" href="#Metoda-konjugiranih-gradientov-s-predpogojevanjem" title="Permalink"></a></h3><p>Za pohitritev konvergence iterativnih metod, se velikokrat izvede t. i. predpogojevanje(angl. preconditioning). Za simetrične pozitivno definitne matrike je to pogosto nepopolni razcep Choleskega, pri katerem sledimo algoritmu za razcep Choleskega, le da ničelne elemente pustimo pri miru.</p><p>Naj bo A <span>$n\times n$</span> pozitivno definitna razpršena matrika(velika večina elementov je ničelnih <span>$a_{ij}=0$</span>). Matriko zaradi prostorskih zahtev hranimo kot <em>sparse</em> matriko. Poglejte si dokumentacijo za <a href="https://docs.julialang.org/en/v1/stdlib/SparseArrays/">razpršene matrike</a>.</p><p>Napišite funkcijo <code>L = nep_chol(A)</code>, ki izračuna nepopolni razcep Choleskega za matriko tipa <code>AbstractSparseMatrix</code>. Napišite še funkcijo <code>x, i = conj_grad(A, b, L)</code>, ki reši linearni sistem</p><p class="math-container">\[Ax = b\]</p><p>s predpogojeno metodo konjugiranih gradientov za matriko <span>$M = L^T L$</span> kot predpogojevalcem. Pri tem pazite, da matrike <span>$M$</span> ne izračunate, ampak uporabite razcep <span>$M = L^TL$</span>. Za različne primere preverite, ali se izboljša hitrost konvergence.</p><h3 id="QR-razcep-zgornje-hessenbergove-matrike"><a class="docs-heading-anchor" href="#QR-razcep-zgornje-hessenbergove-matrike">QR razcep zgornje hessenbergove matrike</a><a id="QR-razcep-zgornje-hessenbergove-matrike-1"></a><a class="docs-heading-anchor-permalink" href="#QR-razcep-zgornje-hessenbergove-matrike" title="Permalink"></a></h3><p>Naj bo <span>$H$</span> <span>$n\times n$</span> zgornje hessenbergova matrika (velja <span>$a_{ij}=0$</span> za <span>$j &lt; j-2i$</span>). Definirajte podatkovni tip <code>ZgornjiHessenberg</code> za zgornje hessenbergovo matriko.</p><p>Napišite funkcijo <code>Q, R = qr(H)</code>, ki izvede QR razcep matrike <code>H</code> tipa <code>ZgornjiHessenberg</code> z Givensovimi rotacijami. Matrika <code>R</code> naj bo zgornje trikotna matrika enakih dimenzij kot <code>H</code>, v <code>Q</code> pa naj bo matrika tipa <code>Givens</code>.</p><p>Podatkovni tip <code>Givens</code> definirajte sami tako, da hrani le zaporedje rotacij, ki se med razcepom izvedejo in indekse vrstic, na katere te rotacije delujejo. Posamezno rotacijo predstavite s parom</p><p class="math-container">\[[\cos(\alpha);\sin(\alpha)],\]</p><p>kjer je α kot rotacije na posameznem koraku. Za podatkovni tip definirajte še množenje <code>Base.*</code> z vektorji in matrikami.</p><p>Uporabite QR razcep za QR iteracijo zgornje hesenbergove matrike. Napišite funkcijo <code>lastne_vrednosti, lastni_vektorji = eigen(H)</code>, ki poišče lastne vrednosti in lastne vektorje zgornje hessenbergove matrike.</p><p>Preverite časovno zahtevnost vaših funkcij in ju primerjajte z metodami <code>qr</code> in <code>eigen</code> za navadne matrike.</p><h3 id="QR-razcep-simetrične-tridiagonalne-matrike"><a class="docs-heading-anchor" href="#QR-razcep-simetrične-tridiagonalne-matrike">QR razcep simetrične tridiagonalne matrike</a><a id="QR-razcep-simetrične-tridiagonalne-matrike-1"></a><a class="docs-heading-anchor-permalink" href="#QR-razcep-simetrične-tridiagonalne-matrike" title="Permalink"></a></h3><p>Naj bo <span>$A$</span> <span>$n × n$</span> simetrična tridiagonalna matrika (velja <span>$a_{ij}=0$</span> za <span>$|i-j|&gt;1$</span>).</p><p>Definirajte podatkovni tip <code>SimetricnaTridiagonalna</code> za simetrično tridiagonalno matriko, ki hrani glavno in stransko diagonalo matrike. Za tip <code>SimetricnaTridiagonalna</code> definirajte metode za naslednje funkcije:</p><ul><li>indeksiranje: <code>Base.getindex</code>,<code>Base.setindex!</code>,<code>Base.firstindex</code> in <code>Base.lastindex</code></li><li>množenje z desne <code>Base.*</code> z vektorjem ali matriko</li></ul><p>Časovna zahtevnost omenjenih funkcij naj bo linearna. Več informacij o <a href="https://docs.julialang.org/en/v1/manual/types/">tipih</a> in Napišite funkcijo <code>Q, R = qr(T)</code>, ki izvede QR razcep matrike <code>T</code> tipa <code>Tridiagonalna</code> z Givensovimi rotacijami. Matrika <code>R</code> naj bo zgornje trikotna dvodiagonalna matrika tipa <code>ZgornjeDvodiagonalna</code>, v <code>Q</code> pa naj bo matrika tipa <code>Givens</code>. <a href="https://docs.julialang.org/en/v1/manual/interfaces/">vmesnikih</a>.</p><p>Podatkovna tipa <code>ZgornjeDvodiagonalna</code> in <code>Givens</code> definirajte sami (glejte tudi nalogo <a href="#QR-razcep-zgornje-hessenbergove-matrike">QR razcep zgornje hessenbergove matrike</a>). Poleg tega implementirajte množenje <code>Base.*</code> matrik tipa <code>Givens</code> in <code>ZgornjeDvodiagonalna</code>.</p><p>Uporabite QR razcep za QR iteracijo simetrične tridiagonalne matrike. Napišite funkcijo <code>lastne_vrednosti, lastni_vektorji = eigen(T)</code>, ki poišče lastne vrednosti in lastne vektorje simetrične tridiagonalne matrike.</p><p>Preverite časovno zahtevnost vaših funkcij in ju primerjajte z metodami <code>qr</code> in <code>eigen</code> za navadne matrike.</p><h3 id="Inverzna-potenčna-metoda-za-zgornje-hessenbergovo-matriko"><a class="docs-heading-anchor" href="#Inverzna-potenčna-metoda-za-zgornje-hessenbergovo-matriko">Inverzna potenčna metoda za zgornje hessenbergovo matriko</a><a id="Inverzna-potenčna-metoda-za-zgornje-hessenbergovo-matriko-1"></a><a class="docs-heading-anchor-permalink" href="#Inverzna-potenčna-metoda-za-zgornje-hessenbergovo-matriko" title="Permalink"></a></h3><p>Lastne vektorje matrike <span>$A$</span> lahko računamo z <strong>inverzno potenčno metodo</strong>. Naj bo <span>$A_\lambda = A-\lambda I$</span>. Če je <span>$\lambda$</span> približek za lastno vrednost, potem zaporedje vektorjev</p><p class="math-container">\[x^{(n+1)}=\frac{A_\lambda^{-1}x^{(n)}}{|A_\lambda^{-1}x^{(n)}|},\]</p><p>konvergira k lastnemu vektorju za lastno vrednost, ki je po absolutni vrednosti najbližje vrednosti <span>$\lambda$</span>.</p><p>Da bi zmanjšali število operacij na eni iteraciji, lahko poljubno matriko <span>$A$</span> prevedemo v zgornje hessenbergovo obliko (velja <span>$a_{ij} = 0$</span> za <span>$j &lt; i - 2$</span>). S hausholderjevimi zrcaljenji lahko poiščemo zgornje hesenbergovo matriko H, ki je podobna matriki A:</p><p class="math-container">\[H=Q^T A Q.\]</p><p>Če je <span>$v$</span> lastni vektor matrike <span>$H$</span>, je <span>$Qv$</span> lastni vektor matrike <span>$A$</span>, lastne vrednosti matrik <span>$H$</span> in <span>$A$</span> pa so enake.</p><p>Napišite funkcijo <code>H, Q = hessenberg(A)</code>, ki s Hausholderjevimi zrcaljenji poišče zgornje hesenbergovo matriko <code>H</code> tipa <code>ZgornjiHessenberg</code>, ki je podobna matriki <code>A</code>.</p><p>Tip <code>ZgornjiHessenberg</code> definirajte sami, kot je opisano v nalogi o QR razcepu zgornje hessenbergove matrike. Poleg tega implementirajte metodo <code>L, U = lu(A)</code> za matrike tipa <code>ZgornjiHessenberg</code>, ki bo pri razcepu upoštevala lastnosti zgornje hessenbergovih matrik. Matrika <code>L</code> naj ne bo polna, ampak tipa <code>SpodnjaTridiagonalna</code>. Tip <code>SpodnjaTridiagonalna</code> definirajte sami, tako da bo hranil le neničelne elemente in za ta tip matrike definirajte operator <code>Base.\</code>, tako da bo upošteval strukturo matrikw <code>L</code>.</p><p>Napišite funkcijo <code>lambda, vektor = inv_lastni(A, l)</code>, ki najprej naredi hessenbergov razcep in nato izračuna lastni vektor in točno lastno matrike <code>A</code>, kjer je <code>l</code> približek za lastno vrednost. Inverza matrike <code>A</code> nikar ne računajte, ampak raje uporabite LU razcep in na vsakem koraku rešite sistem <span>$L(Ux^{n+1})=x^n$</span>.</p><p>Metodo preskusite za izračun ničel polinoma. Polinomu</p><p class="math-container">\[x^n + a_{n-1}x^{n-2} + ... a_1x + a_0\]</p><p>lahko priredimo matriko</p><p class="math-container">\[\begin{bmatrix}
0 &amp;0&amp;\ldots&amp;0&amp;-a_0\\
1&amp;0&amp;\ldots&amp;0&amp;-a_1\\
0&amp;1&amp;\ldots&amp;0&amp;-a_2\\
\vdots &amp;\vdots&amp; \ddots&amp; \vdots&amp;\vdots\\
0 &amp; 0&amp; \ldots &amp;1&amp;-a_{n-1}
\end{bmatrix},\]</p><p>katere lastne vrednosti se ujemajo z ničlami polinoma.</p><h3 id="Inverzna-potenčna-metoda-za-tridiagonalno-matriko"><a class="docs-heading-anchor" href="#Inverzna-potenčna-metoda-za-tridiagonalno-matriko">Inverzna potenčna metoda za tridiagonalno matriko</a><a id="Inverzna-potenčna-metoda-za-tridiagonalno-matriko-1"></a><a class="docs-heading-anchor-permalink" href="#Inverzna-potenčna-metoda-za-tridiagonalno-matriko" title="Permalink"></a></h3><p>Lastne vektorje matrike <span>$A$</span> lahko računamo z <strong>inverzno potenčno metodo</strong>. Naj bo <span>$A_\lambda = A-\lambda I$</span>. Če je <span>$\lambda$</span> približek za lastno vrednost, potem zaporedje vektorjev</p><p class="math-container">\[x^{(n+1)}=\frac{A_\lambda^{-1}x^{(n)}}{|A_\lambda^{-1}x^{(n)}|},\]</p><p>konvergira k lastnemu vektorju za lastno vrednost, ki je po absolutni vrednosti najbližje vrednosti <span>$\lambda$</span>.</p><p>Naj bo <span>$A$</span> <strong>simetrična matrika</strong>. Da bi zmanjšali število operacij na eni iteraciji, lahko poljubno simetrično matriko <span>$A$</span> prevedemo v tridiagonalno obliko. S hausholderjevimi zrcaljenji lahko poiščemo tridiagonalno matriko T, ki je podobna matriki A:</p><p class="math-container">\[T=Q^T A Q.\]</p><p>Če je <span>$v$</span> lastni vektor matrike <span>$T$</span>, je <span>$Qv$</span> lastni vektor matrike <span>$A$</span>, lastne vrednosti matrik <span>$T$</span> in <span>$A$</span> pa so enake.</p><p>Napišite funkcijo <code>T, Q = tridiag(A)</code>, ki s Hausholderjevimi zrcaljenji poišče tridiagonalno matriko <code>H</code> tipa <code>Tridiagonalna</code>, ki je podobna matriki <code>A</code>.</p><p>Tip <code>Tridiagonalna</code> definirajte sami, kot je opisano v nalogi o QR razcepu tridiagonalne matrike. Poleg tega implementirajte metodo <code>L, U = lu(A)</code> za matrike tipa <code>Tridiagonalna</code>, ki bo pri razcepu upoštevala lastnosti tridiagonalnih matrik. Matrike <code>L</code> in <code>U</code> naj ne bodo polne matrike. Matrika <code>L</code> naj bo tipa <code>SpodnjaTridiagonalna</code>, matrika <code>U</code> pa tipa <code>ZgornjaTridiagonalna</code>. Tipa <code>SpodnjaTridiagonalna</code> in <code>ZgornjaTridiagonalna</code> definirajte sami, tako da bosta hranila le neničelne elemente. Za oba tipa definirajte operator <code>Base.\</code>, tako da bo upošteval strukturo matrik.</p><p>Napišite funkcijo <code>lambda, vektor = inv_lastni(A, l)</code>, ki najprej naredi hessenbergov razcep in nato izračuna lastni vektor in točno lastno matrike <code>A</code>, kjer je <code>l</code> približek za lastno vrednost. Inverza matrike <code>A</code> nikar ne računajte, ampak raje uporabite LU razcep in na vsakem koraku rešite sistem <span>$L(Ux^{n+1})=x^n$</span>.</p><p>Metodo preskusite na laplaceovi matriki, ki ima vse elemente <span>$0$</span> razen <span>$l_{ii}=-2, l_{i+1,j}=l_{i,j+1}=1$</span>. Poiščite nekaj lastnih vektorjev za najmanjše lastne vrednosti in jih vizualizirajte z ukazom <code>plot</code>.</p><p>Lastni vektorji laplaceove matrike so približki za rešitev robnega problema za diferencialno enačbo</p><p class="math-container">\[y&#39;&#39;(x) = \lambda^2 y(x),\]</p><p>katere rešitve sta funkciji <span>$\sin(\lambda x)$</span> in <span>$\cos(\lambda x)$</span>.</p><h3 id="Naravni-zlepek"><a class="docs-heading-anchor" href="#Naravni-zlepek">Naravni zlepek</a><a id="Naravni-zlepek-1"></a><a class="docs-heading-anchor-permalink" href="#Naravni-zlepek" title="Permalink"></a></h3><p>Danih je <span>$n$</span> interpolacijskih točk <span>$(x_i,f_i)$</span>, <span>$i=1,2,...,n$</span>. <strong>Naravni interpolacijski kubični zlepek</strong> <span>$S$</span> je funkcija, ki izpolnjuje naslednje pogoje:</p><ol><li><p class="math-container">\[S(x_i)=f_i, \quad i=1,2,...,n.\]</p></li><li><p class="math-container">\[S\]</p>je polinom stopnje <span>$3$</span> ali manj na vsakem podintervalu <span>$[x_i,x_{i+1}]$</span>, <span>$i=1,2,...,n-1$</span>.</li><li><p class="math-container">\[S\]</p>je dvakrat zvezno odvedljiva funkcija na interpolacijskem intervalu <span>$[x_1,x_n]$</span></li><li><p class="math-container">\[S^{\prime\prime}(x_1)=S^{\prime\prime}(x_n)=0\]</p>.</li></ol><p>Zlepek <span>$S$</span> določimo tako, da postavimo</p><p class="math-container">\[S(x)=S_i(x)=a_i+b_i\,(x-x_i)+c_i\,(x-x_i)^2+d_i\,(x-x_i)^3, \quad
  x\in[x_i,x_{i+1}],\]</p><p>nato pa izpolnimo zahtevane pogoje <sup class="footnote-reference"><a id="citeref-2" href="#footnote-2">[2]</a></sup>.</p><p>Napišite funkcijo <code>Z = interpoliraj(x, y)</code>, ki izračuna koeficient polinoma <span>$S_i$</span> in vrne element tipa <code>Zlepek</code>.</p><p>Tip <code>Zlepek</code> definirajte sami in naj vsebuje koeficiente polinoma in interpolacijske točke. Za tip <code>Zlepek</code> napišite dve funkciji</p><ul><li><code>y = vrednost(Z, x)</code>, ki vrne vrednost zlepka v dani točki <code>x</code>.</li><li><code>plot(Z)</code>, ki nariše graf zlepka, tako da različne odseke izmenično nariše z rdečo in modro barvo(uporabi paket <code>Plots</code>).</li></ul><h3 id="QR-iteracija-z-enojnim-premikom"><a class="docs-heading-anchor" href="#QR-iteracija-z-enojnim-premikom">QR iteracija z enojnim premikom</a><a id="QR-iteracija-z-enojnim-premikom-1"></a><a class="docs-heading-anchor-permalink" href="#QR-iteracija-z-enojnim-premikom" title="Permalink"></a></h3><p>Naj bo <span>$A$</span> simetrična matrika. Napišite funkcijo, ki poišče lastne vektorje in vrednosti simetrične matrike z naslednjim algoritmom</p><ul><li>Izvedi Hessenbergov razcep matrike <span>$A=U^T T U$</span> (uporabite lahko vgrajeno funkcijo <code>LinearAlgebra.hessenberg</code>)</li><li>Za tridiagonalno matriko <span>$T$</span> ponavljaj, dokler ni <span>$h_{n-1,n}$</span> dovolj majhen:<ul><li>za <span>$T - \mu I$</span> za <span>$\mu = h_{n,n}$</span> izvedi QR razcep</li><li>nov približek je enak <span>$RQ + \mu I$</span></li></ul></li><li>Postopek ponovi za podmatriko brez zadnjega stolpca in vrstice</li></ul><p>Napiši metodo <code>lastne_vrednosti, lastni_vektorji = eigen(A, EnojniPremik(), vektorji = false)</code>, ki vrne</p><ul><li>vektor lastnih vrednosti simetrične matrike <code>A</code>, če je vrednost <code>vektorji</code> enaka <code>false</code>.</li><li>vektor lastnih vrednosti <code>lambda</code> in matriko s pripadajočimi lastnimi  vektorji <code>V</code>, če je <code>vektorji</code> enaka <code>true</code></li></ul><p>Pazi na časovno in prostorsko zahtevnost algoritma. QR razcep tridiagonalne matrike izvedi z Givensovimi rotacijami in hrani le elemente, ki so nujno potrebni (glej nalogo <a href="#QR-razcep-simetrične-tridiagonalne-matrike">QR razcep simetrične tridiagonalne matrike</a>).</p><p>Funkcijo preiskusi na Laplaceovi matriki grafa podobnosti (glej <a href="../../vaje/3_lastne_vrednosti/06_spektralno_grucenje/">vajo o spektralnem gručenju</a>).</p><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-2"><a class="tag is-link" href="#citeref-2">2</a>pomagajte si z: Bronštejn, Semendjajev, Musiol, Mühlig: <strong>Matematični priročnik</strong>, Tehniška založba Slovenije, 1997, str. 754 ali pa J. Petrišič: <strong>Interpolacija</strong>, Univerza v Ljubljani, Fakulteta za strojništvo, Ljubljana, 1999, str. 47</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../1_domaca/">« 1. domača naloga</a><a class="docs-footer-nextpage" href="../3_domaca/">3. domača naloga »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 23 February 2022 23:51">Wednesday 23 February 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
