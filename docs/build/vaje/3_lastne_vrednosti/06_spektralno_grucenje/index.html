<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Spektralno razvrščanje v gruče · Numerična matematika na FRI</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Numerična matematika na FRI</span></div><form class="docs-search" action="../../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../../">Domov</a></li><li><span class="tocitem">Uvod</span><ul><li><a class="tocitem" href="../../1_uvod/01_koren/">Računanje kvadratnega korena</a></li><li><a class="tocitem" href="../../1_uvod/02_pi/">Računanje števila <span>$\pi$</span></a></li></ul></li><li><span class="tocitem">Linearni sistemi</span><ul><li><a class="tocitem" href="../../2_linearni_sistemi/02_tridiagonalni_sistemi/">Tridiagonalni sistemi</a></li><li><a class="tocitem" href="../../2_linearni_sistemi/03_minimalne_ploskve/">Minimalne ploskve (Laplaceova enačba)</a></li><li><a class="tocitem" href="../../2_linearni_sistemi/04_iteracijske_metode/">Iteracijske metode</a></li><li><a class="tocitem" href="../../2_linearni_sistemi/05_implicitne_ploskve/">Interpolacija z implicitnimi funkcijami</a></li></ul></li><li><span class="tocitem">Lastne vrednosti</span><ul><li><a class="tocitem" href="../06_konj/">Konj na šahovnici</a></li><li class="is-active"><a class="tocitem" href>Spektralno razvrščanje v gruče</a><ul class="internal"><li><a class="tocitem" href="#Podobnostni-graf-in-Laplaceova-matrika"><span>Podobnostni graf in Laplaceova matrika</span></a></li><li><a class="tocitem" href="#Algoritem"><span>Algoritem</span></a></li><li><a class="tocitem" href="#Primer"><span>Primer</span></a></li><li><a class="tocitem" href="#Inverzna-potenčna-metoda"><span>Inverzna potenčna metoda</span></a></li><li><a class="tocitem" href="#Algoritem-k-povprečij"><span>Algoritem k-povprečij</span></a></li><li><a class="tocitem" href="#Literatura"><span>Literatura</span></a></li><li><a class="tocitem" href="#Koda"><span>Koda</span></a></li></ul></li></ul></li><li><span class="tocitem">Nelinearne enačbe</span><ul><li><a class="tocitem" href="../../4_nelinearne_enacbe/01_konvergenca/">Konvergenčna območja iteracijskih metod</a></li><li><a class="tocitem" href="../../4_nelinearne_enacbe/02_razdalja/">Nelinearne enačbe in geometrija</a></li></ul></li><li><span class="tocitem">Interpolacija, aproksimacija</span><ul><li><a class="tocitem" href="../../5_interpolacija/07_zlepki/">Interpolacija z zlepki</a></li><li><a class="tocitem" href="../../6_aproksimacija/co2/">Aproksimacija z linearnim modelom</a></li><li><a class="tocitem" href="../../6_aproksimacija/08_chebfun/">Aproksimacija s polinomi Čebiševa</a></li></ul></li><li><span class="tocitem">Integral</span><ul><li><a class="tocitem" href="../../7_integral/10_quad/">Integrali</a></li><li><a class="tocitem" href="../../7_integral/11_quadnD/">Večrazsežni integrali</a></li></ul></li><li><span class="tocitem">Odvod</span><ul><li><a class="tocitem" href="../../8_odvod/12_autodiff/">Automatsko odvajanje</a></li></ul></li><li><span class="tocitem">Diferencialne enačbe</span><ul><li><a class="tocitem" href="../../9_nde/13_lotka_volterra/">Populacijska dinamika</a></li><li><a class="tocitem" href="../../9_nde/14_perioda/">Perioda geostacionarne orbite</a></li></ul></li><li><span class="tocitem">Domače naloge</span><ul><li><a class="tocitem" href="../../../domace/1_domaca/">1. domača naloga</a></li><li><a class="tocitem" href="../../../domace/2_domaca/">2. domača naloga</a></li><li><a class="tocitem" href="../../../domace/3_domaca/">3. domača naloga</a></li><li><a class="tocitem" href="../../../domace/4_domaca/">4. domača naloga</a></li><li><a class="tocitem" href="../../../contributing/">Kako sodelovati pri predmetu Numerična matematika</a></li><li><a class="tocitem" href="../../../workflow/">Developer documentation</a></li></ul></li><li><span class="tocitem">Knjižnica</span><ul><li><a class="tocitem" href="../../../lib/public/">Vidne funkcije</a></li><li><a class="tocitem" href="../../../lib/internals/">Skrite funkcije</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Lastne vrednosti</a></li><li class="is-active"><a href>Spektralno razvrščanje v gruče</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Spektralno razvrščanje v gruče</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://gitlab.com/nummat/vaje-nummat/blob/master/docs/src/vaje/3_lastne_vrednosti/06_spektralno_grucenje.md#" title="Edit on GitLab"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitLab</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Spektralno-razvrščanje-v-gruče"><a class="docs-heading-anchor" href="#Spektralno-razvrščanje-v-gruče">Spektralno razvrščanje v gruče</a><a id="Spektralno-razvrščanje-v-gruče-1"></a><a class="docs-heading-anchor-permalink" href="#Spektralno-razvrščanje-v-gruče" title="Permalink"></a></h1><p>Pokazali bomo metodo razvrščanja v gruče, ki uporabi spektralno analizo Laplaceove matrike podobnostnega grafa podatkov, zato da podatke preslika v prostor, kjer jih je lažje razvrstiti.</p><h2 id="Podobnostni-graf-in-Laplaceova-matrika"><a class="docs-heading-anchor" href="#Podobnostni-graf-in-Laplaceova-matrika">Podobnostni graf in Laplaceova matrika</a><a id="Podobnostni-graf-in-Laplaceova-matrika-1"></a><a class="docs-heading-anchor-permalink" href="#Podobnostni-graf-in-Laplaceova-matrika" title="Permalink"></a></h2><p>Podatke (množico točk v <span>$\mathbb{R}^n$</span>) želimo razvrstiti v več gruč. Najprej ustvarimo <em>podobnostni uteženi graf</em>, ki povezuje točke, ki so si v nekem smislu blizu. Podobnostni graf lahko ustvarimo na več načinov:</p><ul><li><strong>ε-okolice</strong>: s točko <em>xᵢ</em> povežemo vse točke, ki ležijo v ε-okolici te točke</li><li><strong>k-najbližji sosedi</strong>: <em>xₖ</em> povežemo z <em>xᵢ</em>, če je <em>xₖ</em> med <em>k</em> najbližjimi</li></ul><p>točkami. Tako dobimo usmerjen graf, zato ponavadi upoštevmo povezavo v obe smeri.</p><ul><li><strong>poln utežen graf</strong>: povežemo vse točke, vendar povezave utežimo glede na razdaljo. Pogosto uporabljena utež je nam znana <a href="https://en.wikipedia.org/wiki/Radial_basis_function">radialna bazna funkcija</a></li></ul><p class="math-container">\[w(x_i, x_k) = \exp\left(-\frac{\|x_i-x_k\|^2}{2\sigma^2}\right)\]</p><p>pri kateri s parametrom <span>$\sigma$</span> lahko določamo velikost okolic.</p><p>Grafu podobnosti priredimo matriko uteži</p><p class="math-container">\[W =[w_{ij}],\]</p><p>in Laplaceovo matriko</p><p class="math-container">\[L = D - W,\]</p><p>kjer je <span>$D=[d_{ij}]$</span> diagonalna matrika z elemetni <span>$d_{ii}=\sum_{j}w_{ij}$</span>. Laplaceova matrika <span>$L$</span> je simetrična, nenegativno definitna in ima vedno eno lastno vrednost 0 za lastni vektor iz samih enic.</p><h2 id="Algoritem"><a class="docs-heading-anchor" href="#Algoritem">Algoritem</a><a id="Algoritem-1"></a><a class="docs-heading-anchor-permalink" href="#Algoritem" title="Permalink"></a></h2><p>Velja naslednji izrek, da ima Laplaceova matrika natanko toliko lastnih vektorjev za lastno vrednost 0, kot ima graf komponent za povezanost. Na prvi pogled se zdi, da bi lahko bile komponente kar naše gruče, a se izkaže, da to ni najbolje.</p><ul><li>Poiščemo <em>k</em> najmanjših lastnih vrednosti za Laplaceovo matriko in izračunamonjihove lastne vektorje.</li><li>Označimo matriko lastnih vektorjev <em>Q=[v₁, v₂, ...,vₖ]</em>. Stolpci <em>Qᵀ</em> ustrezajo koordinatam točk v novem prostoru.</li><li>Za stolpce matrike <em>Qᵀ</em> izvedemo nek drug algoritem gručenja (npr. algoritem  <em>k</em> povprečij).</li></ul><div class="admonition is-info"><header class="admonition-header">Algoritem k-povprečij</header><div class="admonition-body"><p>Izberemo si število gruč <span>$k$</span>. Najprej točke naključno razdelimo v <span>$k$</span> gruč.  Nato naslednji postopek ponavljamo, dokler ne konvergira</p><ul><li>izračunamo center posamezne gruče <span>$c_i=\frac{1}{|G_i|}\sum_{j\in G_i}\mathbf{x}_i$</span></li><li>vsako točko razvrstimo v gručo, ki ima najbližji center</li></ul></div></div><h2 id="Primer"><a class="docs-heading-anchor" href="#Primer">Primer</a><a id="Primer-1"></a><a class="docs-heading-anchor-permalink" href="#Primer" title="Permalink"></a></h2><p>Algoritem preverimo na mešanici treh gaussovih porazdelitev</p><pre><code class="language-julia">using Plots
using Random
m = 100;
Random.seed!(12)
x = [1 .+ randn(m, 1); -3 .+ randn(m,1); randn(m,1)];
y = [-2 .+ randn(m, 1); -1 .+ randn(m,1); 1 .+ randn(m,1)];
scatter(x, y, title=&quot;Oblak točk v ravnini&quot;)
savefig(&quot;06_oblak.png&quot;)</code></pre><p><img src="../06_oblak.png" alt="Oblak točk"/></p><p>Izračunamo graf sosednosti z metodo <span>$\varepsilon$</span>-okolic in poiščemo laplaceovo matriko dobljenega grafa.</p><pre><code class="language-julia">using SparseArrays
tocke = [(x[i], y[i]) for i=1:3*m]
r = 0.9
G = graf_eps_okolice(tocke, r)
L = LaplaceovaMatrika(G)
spy(sparse(Matrix(L)), title=&quot;Porazdelitev neničelnih elementov v laplaceovi matriki&quot;)
savefig(&quot;06_laplaceova_matrika_grafa.png&quot;)</code></pre><p><img src="../06_laplaceova_matrika_grafa.png" alt="Neničelni elementi laplaceove matrike"/></p><p>Če izračunamo lastne vektorje in vrednosti laplaceove matrike dobljenega grafa, dobimo 4 najmanjše lastne vrednosti, ki očitno odstopajo od ostalih.</p><pre><code class="language-julia">import LinearAlgebra.eigen
razcep = eigen(Matrix(L))
scatter(razcep.values[1:20], title=&quot;Prvih 20 lastnih vrednosti laplaceove matrike&quot;)
savefig(&quot;06_lastne_vrednosti.png&quot;)</code></pre><p><img src="../06_lastne_vrednosti.png" alt="Lastne vrednosti laplaceove matrike"/></p><pre><code class="language-julia">scatter(razcep.vectors[:,4], razcep.vectors[:,5], title=&quot;Vložitev s komponentami 4. in 5. lastnega vektorja&quot;)
savefig(&quot;06_vlozitev.png&quot;)</code></pre><p><img src="../06_vlozitev.png" alt="Vložitev točk v nov prostor"/></p><h2 id="Inverzna-potenčna-metoda"><a class="docs-heading-anchor" href="#Inverzna-potenčna-metoda">Inverzna potenčna metoda</a><a id="Inverzna-potenčna-metoda-1"></a><a class="docs-heading-anchor-permalink" href="#Inverzna-potenčna-metoda" title="Permalink"></a></h2><p>Ker nas zanima le najmanjših nekaj lastnih vrednosti, lahko njihov izračun in za izračun lastnih vektrojev uporabimo <a href="https://en.wikipedia.org/wiki/Inverse_iteration">inverzno potenčno metodo</a>. Pri inverzni potenčni metodi zgradimo zaporedje približkov z rekurzivno formulo</p><p class="math-container">\[\mathbf{x}^{(k+1)} = \frac{A^{-1}\mathbf{x}^{(n)}}{\|A^{-1}\mathbf{x}^{(n)}\|}\]</p><p>in zaporedje približkov konvergira k lastnemu vektorju za najmanjšo lastno vrednost matrike <span>$A$</span>.</p><div class="admonition is-warning"><header class="admonition-header">Namesto inverza uporabite razcep</header><div class="admonition-body"><p>Računanje inverza je časovno zelo zahtevna operacija, zato se jo razen v nizkih dimenzijah,  če je le mogoče izognemo. Namesto inverza raje uporabimo enega od razcepov matrike <span>$A$</span>.  Če naprimer uporabimo LU razcep <span>$A=LU$</span>, lahko <span>$A^{-1}\mathbf{b}$</span> izračunamo tako, da rešimo   sistem <span>$A\mathbf{x} = \mathbf{b}$</span> oziroma <span>$LU\mathbf{x} = \mathbf{b}$</span> v dveh korakih</p><p>$  \begin{aligned}  L\mathbf{y}&amp;=\mathbf{b}\cr  U\mathbf{x}&amp;=\mathbf{y}  \end{aligned}  $</p><p>Programski jezik <code>julia</code> ima za ta namen prav posebno metodo <a href="https://docs.julialang.org/en/v1/stdlib/LinearAlgebra/index.html#LinearAlgebra.factorize">factorize</a>, ki za različne matrike, izračuna najbolj primeren razcep.</p></div></div><p>Laplaceova matrika je simetrična, zato so lastne vrednosti ortogonalne. Lastne vektorje lahko tako poiščemo tako, da iteracijo izvajamo na več vektorjih hkrati in nato na dobljeni bazi izvedemo ortogonalizacijo (QR razcep), da zaporedje lastnih vektorjev za lastne vrednosti, ki so najbližje najmanjši lastni vrednosti.</p><p>Laplaceova matrika grafa okolic je simetrična in diagonalno dominantna. Poleg tega je zelo veliko elementov enakih 0. Zato za rešitev sistema uporabimo metodo <a href="https://en.wikipedia.org/wiki/Conjugate_gradient_method">konjugiranih gradientov</a>. Za uporabo metode konjugiranih gradientov zadošča, da učinkovito izračunamo množenje matrike z vektorjem. Težava je, ker so je laplaceova matrika grafa izrojena, zato metoda konjugiranih gradientov ne konvergira. Težavo lahko rešimo s premikom. Namesto, da računamo lastne vreednosti in vektorje matrike <span>$L$</span>, iščemo lastne vrednosti in vektorje malce premaknjene matrike <span>$L+\varepsilon I$</span>, ki ima enake lastne vektorje, kot <span>$L$</span>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Programski jezik julia omogoča polimorfizem v obliki <a href="https://docs.julialang.org/en/v1/manual/methods/index.html">večlične dodelitve</a>. Tako lahko za isto funkcijo definiramo različne metode. Za razliko od polmorfizma v objektno orientiranih jezikih, se metoda izbere ne le na podlagi tipa objekta, ki to metodo kliče, ampak na podlagi tipov vseh vhodnih argumentov. To lastnost lahko s pridom uporabimo, da lahko pišemo generično kodo, ki deluje za veliko različnih vhodnih argumentov. Primer je funkcija <a href="../../2_linearni_sistemi/04_iteracijske_metode/#NumMat.conjgrad"><code>conjgrad</code></a>, ki jo lahko uporabimo tako za polne matrike, matrike tipa <code>SparseArray</code> ali pa tipa <code>LaplaceovaMatrika</code> za katerega smo posebej definirali operator množenja <a href="../../2_linearni_sistemi/04_iteracijske_metode/#Base.:*-Tuple{LaplaceovOperator{2}, Matrix}"><code>*</code></a>.</p></div></div><p class="math-container">\[L\mathbf{x^{(k+1)}} = \mathbf{x^{(k)}}\]</p><p>Primerjajmo inverzno potenčno metodo z vgrajeno metodo za iskanje lastnih vrednosti s polno matriko</p><pre><code class="language-julia">import Base:*, size
struct PremikMatrike
   premik
   matrika
end
*(p::PremikMatrike, x) = p.matrika*x + p.premik.*x
size(p::PremikMatrike) = size(p.matrika)

Lp = PremikMatrike(0.01, L)
l, v = inverzna_iteracija(Lp, 5, (Lp, x) -&gt; conjgrad(Lp, x)[1])</code></pre><h2 id="Algoritem-k-povprečij"><a class="docs-heading-anchor" href="#Algoritem-k-povprečij">Algoritem k-povprečij</a><a id="Algoritem-k-povprečij-1"></a><a class="docs-heading-anchor-permalink" href="#Algoritem-k-povprečij" title="Permalink"></a></h2><pre><code class="language-julia">nove_tocke =  [tocka for tocka in zip(razcep.vectors[:,4], razcep.vectors[:,5])]
gruce = kmeans(nove_tocke, 3)

p1 = scatter(tocke[findall(gruce .== 1)], color=:blue, title=&quot;Originalne točke&quot;)
scatter!(p1, tocke[findall(gruce .== 2)], color=:red)
scatter!(p1, tocke[findall(gruce .== 3)], color=:green)

p2 = scatter(nove_tocke[findall(gruce .== 1)], color=:blue, title=&quot;Preslikane točke&quot;)
scatter!(p2, nove_tocke[findall(gruce .== 2)], color=:red)
scatter!(p2, nove_tocke[findall(gruce .== 3)], color=:green)

plot(p1,p2)
savefig(&quot;06_gruce.png&quot;)</code></pre><p><img src="../06_gruce.png" alt="Gruče"/></p><h2 id="Literatura"><a class="docs-heading-anchor" href="#Literatura">Literatura</a><a id="Literatura-1"></a><a class="docs-heading-anchor-permalink" href="#Literatura" title="Permalink"></a></h2><ul><li>Ulrike von Luxburg <a href="https://arxiv.org/abs/0711.0189">A Tutorial on Spectral  Clustering</a></li><li>Peter Arbenz <a href="http://people.inf.ethz.ch/arbenz/ewp/Lnotes/lsevp.pdf">Lecture Notes on Solving Large Scale Eigenvalue Problems</a></li><li>Knjižnica <a href="http://danspielman.github.io/Laplacians.jl/latest/index.html">Laplacians.jl</a></li></ul><h2 id="Koda"><a class="docs-heading-anchor" href="#Koda">Koda</a><a id="Koda-1"></a><a class="docs-heading-anchor-permalink" href="#Koda" title="Permalink"></a></h2><ul><li><a href="#NumMat.kddrevo"><code>NumMat.kddrevo</code></a></li><li><a href="#NumMat.kmeans-Tuple{Any, Int64}"><code>NumMat.kmeans</code></a></li><li><a href="#NumMat.najdi_okolico-Union{Tuple{T}, Tuple{Any, Drevo{T}, T}} where T"><code>NumMat.najdi_okolico</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="NumMat.kmeans-Tuple{Any, Int64}" href="#NumMat.kmeans-Tuple{Any, Int64}"><code>NumMat.kmeans</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">gruce = kmeans(tocke, k)</code></pre><p>Točke <code>tocke</code> razvrsti v gruče z metodo <a href="https://en.wikipedia.org/wiki/K-means_clustering">k-povpečij</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://gitlab.com/nummat/vaje-nummat/blob/bc8c2bfa0885ef20e11bce0b7341812a1edde41e/src/vaje/3_lastne_vrednosti/kmeans.jl#L2-6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NumMat.kddrevo" href="#NumMat.kddrevo"><code>NumMat.kddrevo</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">drevo = kddrevo(tocke, dim, globina)</code></pre><p>Točke iz seznama <code>tocke</code> razvrsti v <a href="https://en.wikipedia.org/wiki/K-d_tree">k-d drevo</a> začenši z dimenzijo <code>dim</code>.</p><p><strong>Primer:</strong></p><p>```jldoctest julia&gt; tocke = [(2,3), (5,4), (9,6), (4,7), (8,1), (7,2)];</p><p>julia&gt; drevo = kddrevo(tocke);</p><p>julia&gt; print(drevo) (5, 4)  <code>--(7, 2)  |</code>–(9, 6)  |   <code>--(8, 1)</code>–(2, 3)      `–(4, 7)</p></div><a class="docs-sourcelink" target="_blank" href="https://gitlab.com/nummat/vaje-nummat/blob/bc8c2bfa0885ef20e11bce0b7341812a1edde41e/src/vaje/3_lastne_vrednosti/kddrevo.jl#L14-34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="NumMat.najdi_okolico-Union{Tuple{T}, Tuple{Any, Drevo{T}, T}} where T" href="#NumMat.najdi_okolico-Union{Tuple{T}, Tuple{Any, Drevo{T}, T}} where T"><code>NumMat.najdi_okolico</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">okolica = najdi_okolico(r, drevo::Drevo{T}, tocka::T; razdalja)</code></pre><p>Poišče točke v <a href="https://en.wikipedia.org/wiki/K-d_tree">k-d drevesu</a>,  ki so manj kot <code>r</code> oddaljeni od dane točke <code>tocka</code>.</p><p><strong>Primer</strong></p><pre><code class="language-julia-repl">julia&gt; drevo = kddrevo([(2,3), (5,4), (9,6), (4,7), (8,1), (7,2)]);

julia&gt; najdi_okolico(2, drevo, (8,2))
2-element Array{Tuple{Int64,Int64},1}:
 (8, 1)
 (7, 2)
 </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://gitlab.com/nummat/vaje-nummat/blob/bc8c2bfa0885ef20e11bce0b7341812a1edde41e/src/vaje/3_lastne_vrednosti/kddrevo.jl#L76-93">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../06_konj/">« Konj na šahovnici</a><a class="docs-footer-nextpage" href="../../4_nelinearne_enacbe/01_konvergenca/">Konvergenčna območja iteracijskih metod »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 1 March 2022 01:24">Tuesday 1 March 2022</span>. Using Julia version 1.7.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
